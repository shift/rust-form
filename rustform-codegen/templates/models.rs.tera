use serde::{Deserialize, Serialize};
use sqlx::FromRow;

{% for model in models -%}
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct {{ model.struct_name }} {
    {% for field in model.fields -%}
    {% if field.is_nullable -%}
    pub {{ field.name }}: Option<{{ field.rust_type }}>,
    {% else -%}
    pub {{ field.name }}: {{ field.rust_type }},
    {% endif -%}
    {% endfor -%}
}

#[derive(Debug, Deserialize)]
pub struct Create{{ model.struct_name }} {
    {% for field in model.fields -%}
    {% if not field.is_primary_key and not field.auto_now and not field.auto_now_add -%}
    {% if field.is_required and not field.is_nullable -%}
    pub {{ field.name }}: {{ field.rust_type }},
    {% else -%}
    pub {{ field.name }}: Option<{{ field.rust_type }}>,
    {% endif -%}
    {% endif -%}
    {% endfor -%}
}

#[derive(Debug, Deserialize)]
pub struct Update{{ model.struct_name }} {
    {% for field in model.fields -%}
    {% if not field.is_primary_key and not field.auto_now and not field.auto_now_add -%}
    pub {{ field.name }}: Option<{{ field.rust_type }}>,
    {% endif -%}
    {% endfor -%}
}

impl {{ model.struct_name }} {
    pub async fn find_all(pool: &sqlx::SqlitePool) -> Result<Vec<Self>, sqlx::Error> {
        let records = sqlx::query_as!(
            Self,
            "SELECT * FROM {{ model.table_name }}"
        )
        .fetch_all(pool)
        .await?;
        
        Ok(records)
    }

    pub async fn find_by_id(pool: &sqlx::SqlitePool, id: {{ model.primary_key_type | default(value="i64") }}) -> Result<Option<Self>, sqlx::Error> {
        let record = sqlx::query_as!(
            Self,
            "SELECT * FROM {{ model.table_name }} WHERE {{ model.primary_key_field | default(value="id") }} = $1",
            id
        )
        .fetch_optional(pool)
        .await?;
        
        Ok(record)
    }

    pub async fn create(pool: &sqlx::SqlitePool, new_record: Create{{ model.struct_name }}) -> Result<Self, sqlx::Error> {
        // This is a simplified create implementation
        // In a real implementation, this would dynamically build the INSERT query
        let record = sqlx::query_as!(
            Self,
            "INSERT INTO {{ model.table_name }} DEFAULT VALUES RETURNING *"
        )
        .fetch_one(pool)
        .await?;
        
        Ok(record)
    }

    pub async fn update(pool: &sqlx::SqlitePool, id: {{ model.primary_key_type | default(value="i64") }}, updates: Update{{ model.struct_name }}) -> Result<Self, sqlx::Error> {
        // This is a simplified update - a real implementation would handle optional fields
        let record = sqlx::query_as!(
            Self,
            "UPDATE {{ model.table_name }} SET updated_at = CURRENT_TIMESTAMP WHERE {{ model.primary_key_field | default(value="id") }} = $1 RETURNING *",
            id
        )
        .fetch_one(pool)
        .await?;
        
        Ok(record)
    }

    pub async fn delete(pool: &sqlx::SqlitePool, id: {{ model.primary_key_type | default(value="i64") }}) -> Result<(), sqlx::Error> {
        sqlx::query!(
            "DELETE FROM {{ model.table_name }} WHERE {{ model.primary_key_field | default(value="id") }} = $1",
            id
        )
        .execute(pool)
        .await?;
        
        Ok(())
    }
}

{% endfor -%}