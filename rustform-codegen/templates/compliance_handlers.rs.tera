// Auto-generated compliance-aware handlers for {{ project_name }}
// Generated with GDPR, CCPA, and other regulatory compliance built-in

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    middleware,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use tower_http::cors::CorsLayer;
use tracing::{info, warn, error};

use crate::{
    models::*,
    services::*,
    compliance::{ComplianceService, DataClassification, AuditService},
    error::AppError,
    AppState,
};

pub fn create_router() -> Router<AppState> {
    Router::new()
        {% for endpoint in api.endpoints %}
        .route("{{ endpoint.path }}", {{ endpoint.method | lower }}({{ endpoint.handler }}))
        {% endfor %}
        {% if compliance.frameworks contains "gdpr" %}
        // GDPR-required endpoints (Articles 15-21)
        .route("/privacy/data-request", post(submit_data_subject_request))
        .route("/privacy/requests", get(list_data_subject_requests))
        .route("/privacy/requests/:id", get(get_request_details))
        .route("/privacy/data-export/:request_id/:export_id", get(download_data_export))
        .route("/privacy/consent", put(update_consent))
        .route("/privacy/consent/:category", delete(withdraw_consent))
        {% endif %}
        {% if compliance.frameworks contains "ccpa" %}
        // CCPA-required endpoints
        .route("/privacy/ccpa/opt-out", post(ccpa_opt_out_request))
        .route("/privacy/ccpa/disclosure", get(ccpa_data_disclosure))
        .route("/privacy/ccpa/delete", post(ccpa_deletion_request))
        {% endif %}
        // Compliance middleware for audit logging
        .layer(middleware::from_fn(compliance_audit_middleware))
        {% if compliance.audit.encryption_required %}
        .layer(middleware::from_fn(encryption_middleware))
        {% endif %}
        .layer(CorsLayer::permissive())
}

{% for model in models %}
{% if model.compliance.data_subject %}
// Compliance-aware handlers for {{ model.name }}
// Data Subject: {{ model.name }} ({{ model.compliance.retention_period }} retention)

#[derive(Serialize, Deserialize)]
pub struct {{ model.name }}Response {
    {% for field in model.fields %}
    {% if not field.compliance.personal_data or field.compliance.consent_category in user_consents %}
    pub {{ field.name }}: {{ field.type | rust_type }},
    {% endif %}
    {% endfor %}
    // Compliance metadata
    pub data_retention_expires: Option<chrono::DateTime<chrono::Utc>>,
    pub consents_granted: Vec<String>,
}

#[derive(Deserialize)]
pub struct Create{{ model.name }}Request {
    {% for field in model.fields %}
    {% if field.required and not field.primary_key %}
    pub {{ field.name }}: {{ field.type | rust_type }},
    {% endif %}
    {% endfor %}
    // Compliance fields
    {% if compliance.consent_management.granular_consent %}
    pub consents: std::collections::HashMap<String, bool>,
    {% endif %}
    {% if compliance.data_classification.auto_classification %}
    pub data_processing_purposes: Vec<String>,
    {% endif %}
}

pub async fn create_{{ model.name | snake_case }}(
    State(app_state): State<AppState>,
    Json(payload): Json<Create{{ model.name }}Request>,
) -> Result<Json<{{ model.name }}Response>, StatusCode> {
    {% if compliance.consent_management.granular_consent %}
    // Verify required consents are granted (GDPR Article 6)
    if !verify_required_consents(&payload.consents).await? {
        warn!("Consent verification failed for {{ model.name }} creation");
        return Err(StatusCode::BAD_REQUEST);
    }
    {% endif %}

    {% if compliance.data_classification.auto_classification %}
    // Auto-classify personal data fields
    let classification = app_state.compliance_service
        .classify_personal_data(&payload).await?;
    {% endif %}

    // Create the record with compliance tracking
    let {{ model.name | snake_case }} = {{ model.name }} {
        id: Uuid::new_v4(),
        {% for field in model.fields %}
        {% if not field.primary_key %}
        {{ field.name }}: payload.{{ field.name }},
        {% endif %}
        {% endfor %}
        created_at: chrono::Utc::now(),
        {% if model.compliance.retention_period %}
        retention_expires_at: Some(chrono::Utc::now() + chrono::Duration::days({{ model.compliance.retention_period | parse_duration }})),
        {% endif %}
    };

    // Store with audit trail
    let result = app_state.{{ model.name | snake_case }}_service
        .create_with_compliance(&{{ model.name | snake_case }}).await?;

    {% if compliance.consent_management.granular_consent %}
    // Record consent grants
    for (category, granted) in payload.consents {
        if granted {
            app_state.consent_service.record_consent(
                &{{ model.name | snake_case }}.id.to_string(),
                &category,
                "{{ model.name }} creation",
                chrono::Utc::now(),
            ).await?;
        }
    }
    {% endif %}

    // Log creation for audit (GDPR Article 30)
    app_state.audit_service.log_data_creation(
        "{{ model.name | snake_case }}",
        &{{ model.name | snake_case }}.id.to_string(),
        &serde_json::to_value(&{{ model.name | snake_case }})?,
    ).await?;

    Ok(Json({{ model.name }}Response::from_model(result, &app_state.user_consents).await?))
}

pub async fn get_{{ model.name | snake_case }}(
    State(app_state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<{{ model.name }}Response>, StatusCode> {
    // Check data retention expiry
    if let Some(record) = app_state.{{ model.name | snake_case }}_service.get(id).await? {
        {% if model.compliance.retention_period %}
        if let Some(expires_at) = record.retention_expires_at {
            if expires_at < chrono::Utc::now() {
                warn!("Attempted access to expired data: {{ model.name }} {}", id);
                return Err(StatusCode::GONE); // 410 Gone - data has expired
            }
        }
        {% endif %}

        // Log data access for audit
        app_state.audit_service.log_data_access(
            "{{ model.name | snake_case }}",
            &id.to_string(),
            Some(&app_state.current_user_id()),
        ).await?;

        // Filter response based on current consents
        let response = {{ model.name }}Response::from_model(record, &app_state.user_consents).await?;
        Ok(Json(response))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

pub async fn update_{{ model.name | snake_case }}(
    State(app_state): State<AppState>,
    Path(id): Path<Uuid>,
    Json(update): Json<Update{{ model.name }}Request>,
) -> Result<Json<{{ model.name }}Response>, StatusCode> {
    // Get existing record for audit trail
    let existing = app_state.{{ model.name | snake_case }}_service.get(id).await?
        .ok_or(StatusCode::NOT_FOUND)?;

    {% if model.compliance.data_subject %}
    // Verify user has right to modify this data (GDPR Article 16)
    app_state.compliance_service
        .verify_modification_rights(&existing, &app_state.current_user_id()).await?;
    {% endif %}

    // Update the record
    let updated = app_state.{{ model.name | snake_case }}_service
        .update_with_compliance(id, update).await?;

    // Log modification for audit trail
    app_state.audit_service.log_data_modification(
        "{{ model.name | snake_case }}",
        &id.to_string(),
        &serde_json::to_value(&existing)?,
        &serde_json::to_value(&updated)?,
    ).await?;

    Ok(Json({{ model.name }}Response::from_model(updated, &app_state.user_consents).await?))
}

pub async fn delete_{{ model.name | snake_case }}(
    State(app_state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<StatusCode, StatusCode> {
    {% if model.compliance.data_subject %}
    // Check if this is a GDPR deletion request (right to be forgotten)
    let is_gdpr_deletion = app_state.compliance_service
        .is_gdpr_deletion_request(id).await?;

    if is_gdpr_deletion {
        // Use GDPR-compliant deletion process
        app_state.gdpr_deletion_service
            .delete_with_cascade(id, &{{ model.compliance.deletion_cascade }}).await?;
    } else {
        // Regular business deletion
        app_state.{{ model.name | snake_case }}_service.delete(id).await?;
    }
    {% else %}
    // Standard deletion for non-personal data
    app_state.{{ model.name | snake_case }}_service.delete(id).await?;
    {% endif %}

    // Log deletion
    app_state.audit_service.log_data_deletion(
        "{{ model.name | snake_case }}",
        &id.to_string(),
    ).await?;

    Ok(StatusCode::NO_CONTENT)
}

impl {{ model.name }}Response {
    async fn from_model(model: {{ model.name }}, user_consents: &std::collections::HashMap<String, bool>) -> Result<Self, AppError> {
        Ok(Self {
            {% for field in model.fields %}
            {% if not field.compliance.personal_data %}
            {{ field.name }}: model.{{ field.name }},
            {% else %}
            {% if field.compliance.consent_category %}
            {{ field.name }}: if user_consents.get("{{ field.compliance.consent_category }}").unwrap_or(&false) {
                Some(model.{{ field.name }})
            } else {
                None
            },
            {% else %}
            {{ field.name }}: model.{{ field.name }},
            {% endif %}
            {% endif %}
            {% endfor %}
            {% if model.compliance.retention_period %}
            data_retention_expires: model.retention_expires_at,
            {% else %}
            data_retention_expires: None,
            {% endif %}
            consents_granted: user_consents.iter()
                .filter(|(_, granted)| **granted)
                .map(|(category, _)| category.clone())
                .collect(),
        })
    }
}
{% endif %}
{% endfor %}

// Compliance middleware for automatic audit logging
pub async fn compliance_audit_middleware<B>(
    req: axum::extract::Request,
    next: axum::middleware::Next<B>,
) -> Result<axum::response::Response, StatusCode> {
    let method = req.method().clone();
    let path = req.uri().path().to_string();
    let user_agent = req.headers()
        .get("user-agent")
        .and_then(|h| h.to_str().ok())
        .unwrap_or("unknown");
    
    // Extract user ID from headers or session
    let user_id = extract_user_id(&req).await;
    let ip_address = extract_client_ip(&req);

    let start_time = std::time::Instant::now();
    let response = next.run(req).await;
    let duration = start_time.elapsed();

    // Log the request for compliance audit
    tokio::spawn(async move {
        if let Err(e) = log_compliance_event(ComplianceAuditEvent {
            event_type: "api_request".to_string(),
            method: method.to_string(),
            path,
            user_id,
            ip_address,
            user_agent: user_agent.to_string(),
            status_code: response.status().as_u16(),
            duration_ms: duration.as_millis() as u64,
            timestamp: chrono::Utc::now(),
        }).await {
            error!("Failed to log compliance audit event: {}", e);
        }
    });

    Ok(response)
}

{% if compliance.frameworks contains "gdpr" %}
// GDPR Data Subject Rights Endpoints

pub async fn submit_data_subject_request(
    State(app_state): State<AppState>,
    Json(request): Json<DataSubjectRequestPayload>,
) -> Result<Json<DataSubjectRequestResponse>, StatusCode> {
    // Validate request
    if request.subject_identifier.is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Create and process the request
    let gdpr_request = app_state.gdpr_service
        .submit_request(request).await?;

    Ok(Json(DataSubjectRequestResponse {
        request_id: gdpr_request.id,
        reference_number: gdpr_request.reference_number,
        status: "submitted".to_string(),
        estimated_completion: "30 days".to_string(),
        next_steps: "You will receive a confirmation email with further instructions.".to_string(),
    }))
}

pub async fn update_consent(
    State(app_state): State<AppState>,
    Json(consent_update): Json<ConsentUpdateRequest>,
) -> Result<Json<ConsentResponse>, StatusCode> {
    // Update consent records
    let updated_consents = app_state.consent_service
        .update_consents(&consent_update.subject_id, consent_update.consents).await?;

    // If essential consents are withdrawn, trigger account deactivation
    if consent_update.consents.iter().any(|(category, granted)| {
        category == "essential" && !granted
    }) {
        app_state.compliance_service
            .trigger_account_deactivation(&consent_update.subject_id).await?;
    }

    Ok(Json(ConsentResponse {
        consents: updated_consents,
        updated_at: chrono::Utc::now(),
    }))
}
{% endif %}

{% if compliance.frameworks contains "ccpa" %}
// CCPA Consumer Rights Endpoints

pub async fn ccpa_opt_out_request(
    State(app_state): State<AppState>,
    Json(request): Json<CcpaOptOutRequest>,
) -> Result<Json<CcpaOptOutResponse>, StatusCode> {
    // Process CCPA opt-out (Do Not Sell)
    app_state.ccpa_service
        .process_opt_out(&request.consumer_id).await?;

    Ok(Json(CcpaOptOutResponse {
        status: "processed".to_string(),
        effective_date: chrono::Utc::now(),
        reference_number: format!("CCPA-{}", Uuid::new_v4()),
    }))
}

pub async fn ccpa_data_disclosure(
    State(app_state): State<AppState>,
    Query(params): Query<CcpaDisclosureQuery>,
) -> Result<Json<CcpaDisclosureResponse>, StatusCode> {
    // Provide CCPA-required disclosure of data categories and sources
    let disclosure = app_state.ccpa_service
        .generate_disclosure(&params.consumer_id).await?;

    Ok(Json(disclosure))
}
{% endif %}

// Helper functions
async fn verify_required_consents(consents: &std::collections::HashMap<String, bool>) -> Result<bool, AppError> {
    // Check that all required consent categories are granted
    let required_categories = vec!["essential", "terms_of_service"];
    
    for category in required_categories {
        if !consents.get(category).unwrap_or(&false) {
            return Ok(false);
        }
    }
    
    Ok(true)
}

async fn extract_user_id<B>(req: &axum::extract::Request) -> Option<String> {
    // Extract user ID from JWT, session, or other auth mechanism
    // Implementation depends on your auth system
    None
}

fn extract_client_ip<B>(req: &axum::extract::Request) -> Option<String> {
    // Extract client IP from headers or connection info
    req.headers()
        .get("x-forwarded-for")
        .or_else(|| req.headers().get("x-real-ip"))
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string())
}

async fn log_compliance_event(event: ComplianceAuditEvent) -> Result<(), AppError> {
    // Log to audit database
    // Implementation would store in gdpr_audit_events table
    Ok(())
}

#[derive(Serialize, Deserialize)]
pub struct ComplianceAuditEvent {
    pub event_type: String,
    pub method: String,
    pub path: String,
    pub user_id: Option<String>,
    pub ip_address: Option<String>,
    pub user_agent: String,
    pub status_code: u16,
    pub duration_ms: u64,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

// Retention policy enforcement (automated cleanup)
pub async fn enforce_retention_policies(app_state: &AppState) -> Result<(), AppError> {
    info!("Starting retention policy enforcement");

    {% for policy in compliance.retention_policies %}
    // {{ policy.data_category }} retention: {{ policy.retention_period }}
    let expired_count = app_state.retention_service
        .cleanup_expired_data("{{ policy.data_category }}", "{{ policy.retention_period }}")
        .await?;
    
    if expired_count > 0 {
        info!("Cleaned up {} expired records for {{ policy.data_category }}", expired_count);
    }
    {% endfor %}

    Ok(())
}