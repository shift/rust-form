// Generated API client for {{ project_name }}
// This file is auto-generated. Do not edit manually.

import { 
  {% for model in models -%}
  {{ model.struct_name }}, 
  Create{{ model.struct_name }}Request, 
  Update{{ model.struct_name }}Request,
  {{ model.struct_name }}Filters,
  {% endfor -%}
  PaginatedResponse,
  ApiError,
} from './types';

export interface ApiClientConfig {
  baseUrl: string;
  headers?: Record<string, string>;
}

export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public response?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export class ApiClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(config: ApiClientConfig) {
    this.baseUrl = config.baseUrl.replace(/\/$/, ''); // Remove trailing slash
    this.headers = {
      'Content-Type': 'application/json',
      ...config.headers,
    };
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    const config: RequestInit = {
      headers: this.headers,
      ...options,
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new ApiError(
          errorData.message || `HTTP ${response.status}: ${response.statusText}`,
          response.status,
          errorData
        );
      }

      return await response.json();
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError(`Network error: ${error.message}`, 0, error);
    }
  }

  // Authentication methods
  setAuthToken(token: string) {
    this.headers['Authorization'] = `Bearer ${token}`;
  }

  removeAuthToken() {
    delete this.headers['Authorization'];
  }

  {% for model in models %}
  // {{ model.struct_name }} API methods
  {{ model.name | lower }} = {
    // Get all {{ model.name | lower }}s
    getAll: async (params?: { page?: number; per_page?: number; sort_by?: string; sort_order?: 'asc' | 'desc' }): Promise<PaginatedResponse<{{ model.struct_name }}>> => {
      const query = new URLSearchParams();
      if (params?.page) query.append('page', params.page.toString());
      if (params?.per_page) query.append('per_page', params.per_page.toString());
      if (params?.sort_by) query.append('sort_by', params.sort_by);
      if (params?.sort_order) query.append('sort_order', params.sort_order);
      
      return this.request<PaginatedResponse<{{ model.struct_name }}>>(
        `/api/{{ model.name | lower }}s${query.toString() ? '?' + query.toString() : ''}`
      );
    },

    // Get {{ model.name | lower }} by ID
    getById: async (id: string): Promise<{{ model.struct_name }}> => {
      return this.request<{{ model.struct_name }}>(`/api/{{ model.name | lower }}s/${id}`);
    },

    // Create new {{ model.name | lower }}
    create: async (data: Create{{ model.struct_name }}Request): Promise<{{ model.struct_name }}> => {
      return this.request<{{ model.struct_name }}>(`/api/{{ model.name | lower }}s`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    // Update {{ model.name | lower }}
    update: async (id: string, data: Update{{ model.struct_name }}Request): Promise<{{ model.struct_name }}> => {
      return this.request<{{ model.struct_name }}>(`/api/{{ model.name | lower }}s/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
      });
    },

    // Partially update {{ model.name | lower }}
    patch: async (id: string, data: Partial<Update{{ model.struct_name }}Request>): Promise<{{ model.struct_name }}> => {
      return this.request<{{ model.struct_name }}>(`/api/{{ model.name | lower }}s/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    // Delete {{ model.name | lower }}
    delete: async (id: string): Promise<void> => {
      await this.request<void>(`/api/{{ model.name | lower }}s/${id}`, {
        method: 'DELETE',
      });
    },

    // Search {{ model.name | lower }}s
    search: async (filters: Partial<{{ model.struct_name }}Filters>): Promise<PaginatedResponse<{{ model.struct_name }}>> => {
      const query = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          query.append(key, value.toString());
        }
      });
      
      return this.request<PaginatedResponse<{{ model.struct_name }}>>(
        `/api/{{ model.name | lower }}s/search${query.toString() ? '?' + query.toString() : ''}`
      );
    },
  };

  {% endfor %}
}

// Default API client instance
{% if frontend.api_base_url -%}
export const apiClient = new ApiClient({
  baseUrl: '{{ frontend.api_base_url }}',
});
{% else -%}
export const apiClient = new ApiClient({
  baseUrl: process.env.NODE_ENV === 'development' 
    ? 'http://localhost:{{ server.port | default(value=3000) }}'
    : '/api',
});
{% endif -%}

// Type-safe wrapper functions for easier usage
{% for model in models %}
export const {{ model.name | camel_case }}Api = apiClient.{{ model.name | lower }};
{% endfor %}